import{Fragment as t,options as e,Component as n}from"preact";import"preact/devtools";let o={};function r(){o={}}function i(e){return e.type===t?"Fragment":"function"==typeof e.type?e.type.displayName||e.type.name:"string"==typeof e.type?e.type:"#text"}let a=[],s=[];function l(){return a.length>0?a[a.length-1]:null}let c=!1;function p(e){return"function"==typeof e.type&&e.type!=t}function u(t){const e=[t];let n=t;for(;null!=n.__o;)e.push(n.__o),n=n.__o;return e.reduce((t,e)=>{t+=`  in ${i(e)}`;const n=e.__source;return n?t+=` (at ${n.fileName}:${n.lineNumber})`:c||(c=!0,console.warn("Add @babel/plugin-transform-react-jsx-source to get a more detailed component stack. Note that you should not add it to production builds of your App for bundle size reasons.")),t+"\n"},"")}const d="function"==typeof WeakMap;function f(t){return t?"function"==typeof t.type?f(t.__):t:{}}const h=n.prototype.setState;n.prototype.setState=function(t,e){return null==this.__v?null==this.state&&console.warn(`Calling "this.setState" inside the constructor of a component is a no-op and might be a bug in your application. Instead, set "this.state = {}" directly.\n\n${u(l())}`):null==this.__P&&console.warn(`Can't call "this.setState" on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.\n\n${u(this.__v)}`),h.call(this,t,e)};const y=n.prototype.forceUpdate;function m(t){let{props:e}=t,n=i(t),o="";for(let t in e)if(e.hasOwnProperty(t)&&"children"!==t){let n=e[t];"function"==typeof n&&(n=`function ${n.displayName||n.name}() {}`),n=Object(n)!==n||n.toString?n+"":Object.prototype.toString.call(n),o+=` ${t}=${JSON.stringify(n)}`}let r=e.children;return`<${n}${o}${r&&r.length?">..</"+n+">":" />"}`}n.prototype.forceUpdate=function(t){return null==this.__v?console.warn(`Calling "this.forceUpdate" inside the constructor of a component is a no-op and might be a bug in your application.\n\n${u(l())}`):null==this.__P&&console.warn(`Can't call "this.forceUpdate" on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.\n\n${u(this.__v)}`),y.call(this,t)},function(){!function(){let t=e.__b,n=e.diffed,o=e.__,r=e.vnode,i=e.__r;e.diffed=t=>{p(t)&&s.pop(),a.pop(),n&&n(t)},e.__b=e=>{p(e)&&a.push(e),t&&t(e)},e.__=(t,e)=>{s=[],o&&o(t,e)},e.vnode=t=>{t.__o=s.length>0?s[s.length-1]:null,r&&r(t)},e.__r=t=>{p(t)&&s.push(t),i&&i(t)}}();let t=!1,n=e.__b,r=e.diffed,l=e.vnode,c=e.__e,h=e.__,y=e.__h;const b=d?{useEffect:new WeakMap,useLayoutEffect:new WeakMap,lazyPropTypes:new WeakMap}:null,$=[];e.__e=(t,e,n)=>{if(e&&e.__c&&"function"==typeof t.then){const n=t;t=new Error(`Missing Suspense. The throwing component was: ${i(e)}`);let o=e;for(;o;o=o.__)if(o.__c&&o.__c.__c){t=n;break}if(t instanceof Error)throw t}try{c(t,e,n),"function"!=typeof t.then&&setTimeout(()=>{throw t})}catch(t){throw t}},e.__=(t,e)=>{if(!e)throw new Error("Undefined parent passed to render(), this is the second argument.\nCheck if the element is available in the DOM/has the correct id.");let n;switch(e.nodeType){case 1:case 11:case 9:n=!0;break;default:n=!1}if(!n){let n=i(t);throw new Error(`Expected a valid HTML node as a second argument to render.\tReceived ${e} instead: render(<${n} />, ${e});`)}h&&h(t,e)},e.__b=e=>{let{type:r,__:a}=e,s=f(a);if(t=!0,void 0===r)throw new Error("Undefined component passed to createElement()\n\nYou likely forgot to export your component or might have mixed up default and named imports"+m(e)+`\n\n${u(e)}`);if(null!=r&&"object"==typeof r){if(void 0!==r.__k&&void 0!==r.__e)throw new Error(`Invalid type passed to createElement(): ${r}\n\nDid you accidentally pass a JSX literal as JSX twice?\n\n  let My${i(e)} = ${m(r)};\n  let vnode = <My${i(e)} />;\n\nThis usually happens when you export a JSX literal and not the component.\n\n${u(e)}`);throw new Error("Invalid type passed to createElement(): "+(Array.isArray(r)?"array":r))}if("thead"!==r&&"tfoot"!==r&&"tbody"!==r||"table"===s.type?"tr"===r&&"thead"!==s.type&&"tfoot"!==s.type&&"tbody"!==s.type&&"table"!==s.type?console.error("Improper nesting of table. Your <tr> should have a <thead/tbody/tfoot/table> parent."+m(e)+`\n\n${u(e)}`):"td"===r&&"tr"!==s.type?console.error("Improper nesting of table. Your <td> should have a <tr> parent."+m(e)+`\n\n${u(e)}`):"th"===r&&"tr"!==s.type&&console.error("Improper nesting of table. Your <th> should have a <tr>."+m(e)+`\n\n${u(e)}`):console.error("Improper nesting of table. Your <thead/tbody/tfoot> should have a <table> parent."+m(e)+`\n\n${u(e)}`),void 0!==e.ref&&"function"!=typeof e.ref&&"object"!=typeof e.ref&&!("$$typeof"in e))throw new Error(`Component's "ref" property should be a function, or an object created by createRef(), but got [${typeof e.ref}] instead\n`+m(e)+`\n\n${u(e)}`);if("string"==typeof e.type)for(const t in e.props)if("o"===t[0]&&"n"===t[1]&&"function"!=typeof e.props[t]&&null!=e.props[t])throw new Error(`Component's "${t}" property should be a function, but got [${typeof e.props[t]}] instead\n`+m(e)+`\n\n${u(e)}`);if("function"==typeof e.type&&e.type.propTypes){if("Lazy"===e.type.displayName&&b&&!b.lazyPropTypes.has(e.type)){const t="PropTypes are not supported on lazy(). Use propTypes on the wrapped component itself. ";try{const n=e.type();b.lazyPropTypes.set(e.type,!0),console.warn(t+`Component wrapped in lazy() is ${i(n)}`)}catch(e){console.warn(t+"We will log the wrapped component's name once it is loaded.")}}let t=e.props;e.type.__f&&(t=function(t,e){for(let n in e)t[n]=e[n];return t}({},t),delete t.ref),function(t,e,n,r,i){Object.keys(t).forEach(n=>{let a;try{a=t[n](e,n,r,"prop",null,"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED")}catch(t){a=t}a&&!(a.message in o)&&(o[a.message]=!0,console.error(`Failed prop type: ${a.message}${i&&`\n${i()}`||""}`))})}(e.type.propTypes,t,0,i(e),()=>u(e))}n&&n(e)},e.__h=(e,n,o)=>{if(!e||!t)throw new Error("Hook can only be invoked from render methods.");y&&y(e,n,o)};const w=(t,e)=>({get(){const n="get"+t+e;$&&$.indexOf(n)<0&&($.push(n),console.warn(`getting vnode.${t} is deprecated, ${e}`))},set(){const n="set"+t+e;$&&$.indexOf(n)<0&&($.push(n),console.warn(`setting vnode.${t} is not allowed, ${e}`))}}),g={nodeName:w("nodeName","use vnode.type"),attributes:w("attributes","use vnode.props"),children:w("children","use vnode.props.children")},v=Object.create({},g);e.vnode=t=>{const e=t.props;if(null!==t.type&&null!=e&&("__source"in e||"__self"in e)){const n=t.props={};for(let o in e){const r=e[o];"__source"===o?t.__source=r:"__self"===o?t.__self=r:n[o]=r}}t.__proto__=v,l&&l(t)},e.diffed=e=>{if(e.__k&&e.__k.forEach(t=>{if(t&&void 0===t.type){delete t.__,delete t.__b;const n=Object.keys(t).join(",");throw new Error(`Objects are not valid as a child. Encountered an object with the keys {${n}}.\n\n${u(e)}`)}}),t=!1,r&&r(e),null!=e.__k){const t=[];for(let n=0;n<e.__k.length;n++){const o=e.__k[n];if(!o||null==o.key)continue;const r=o.key;if(-1!==t.indexOf(r)){console.error(`Following component has two or more children with the same key attribute: "${r}". This may cause glitches and misbehavior in rendering process. Component: \n\n`+m(e)+`\n\n${u(e)}`);break}t.push(r)}}}}();export{r as resetPropWarnings};
//# sourceMappingURL=debug.modern.js.map
